#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <SDL/SDL.h>
#include <SDL/SDL_ttf.h>

#include "../inc/main.h"


// Process events generated by the user
// Return user data (datauser_t structure)
void processEvent(datauser_t* data) {
  SDL_Event event;
  int status = 1;     // status = 0 indicates that the event is fully recovered
  while (status) {      // As long as the event is not fully recovered (combinaison of CTRL + <keyboard> to get numbers and special caracters)
    SDL_WaitEvent(&event);      // Wait for an event generated by the user
    switch(event.type) {
      case SDL_QUIT:      // Ask to quit the SDL window
        status = 0;
        data->code = -1;      // data.code update
        break;
      case SDL_KEYUP:       // A keyboard is released
        if (event.key.keysym.sym == SDLK_LSHIFT)        // If the keyboard is SHIFT button
          data->control = 0;                        // data.control is reset to 0
        break;
      case SDL_KEYDOWN:                           // A keyboard is pressed
        if (data->code > 0 && data->code < 6) {       // If the user has previously clicked on a text field
          if (event.key.keysym.sym == SDLK_LSHIFT) {       // If the pressed key is SHIFT
            data->control = 1;                          // data.control is set to 1
            break;
          }
          if (data->control == 1) {                               // If the user is already pressing the SHIFT key
            if (event.key.keysym.sym > 96 && event.key.keysym.sym < 123) {      // If the user is pressing a letter key at the same time
              data->string = (char)event.key.keysym.sym - 32;              // Update data.string with the corresponding uppercase letter (-32 because of the ASCII code)
              status = 0;
              break;
            }
            switch(event.key.keysym.sym) {            // If the user is pressing a key which is not a letter
              case SDLK_SEMICOLON:                  // If the pressed key is ';'
                data->string = '.';
                break;
              case SDLK_COLON:                     // If the pressed key is ':'
                data->string = '/';
                break;
              case SDLK_COMMA:                    // If the pressed key is ','
                data->string = '?';
                break;
              case SDLK_AMPERSAND:                // If the pressed key is '&'
                data->string = '1';
                break;
              case 233:                          // If the pressed key is 'é'
                data->string = '2';
                break;
              case SDLK_QUOTEDBL:               // If the pressed key is '"'
                data->string = '3';
                break;
              case SDLK_QUOTE:                  // If the pressed key is "'"
                data->string = '4';
                break;
              case SDLK_LEFTPAREN:              // If the pressed key is "("
                data->string = '5';
                break;
              case SDLK_MINUS:                  // If the pressed key is "-"
                data->string = '6';
                break;
              case 232:                         // If the pressed key is "è"
                data->string = '7';
                break;
              case SDLK_UNDERSCORE:           // If the pressed key is "_"
                data->string = '8';
                break;
              case 231:                        // If the pressed key is "ç"
                data->string = '9';
                break;
              case 224:                         // If the pressed key is "à"
                data->string = '0';
                break;
            }
          }
          else {        // If the SHIFT key was not previously pressed
            switch(event.key.keysym.sym) {      // Processing of special characters with an accent + normal letters
              case 233:
                strcpy(data->accent, "é");
                break;
              case 232:
                strcpy(data->accent, "è");
                break;
              case 231:
                strcpy(data->accent, "ç");
                break;
              case 224:
                strcpy(data->accent, "à");
                break;
              case 249:
                strcpy(data->accent, "ù");
                break;
              case 8:       // "DELETE" key
                data->control = 2;
                break;
              default:      // usual letter (a to z)
                data->string = (char)event.key.keysym.sym;      // Update data.string with the corresponding key value
                break;
            }
          }
          status = 0;                         // In any case, the event is fully recovered, so we can quit the function
        }
        break;
      case SDL_MOUSEBUTTONDOWN:             // User has clicked on the mouse
        data->string = '\0';
        if (event.button.button == SDL_BUTTON_LEFT) {     // if this is a left click with the mouse
          if (event.button.x > 255 && event.button.x < 455 && event.button.y > 394 && event.button.y < 416)     // If the 'filename' text field is selected
            data->code = 1;
          else if (event.button.x > 175 && event.button.x < 205 && event.button.y > 275 && event.button.y < 297)    // If the 'departureindex' text field is selected
            data->code = 2;
          else if (event.button.x > 175 && event.button.x < 205 && event.button.y > 325 && event.button.y < 347)    // If the 'arrivalindex' text field is selected
            data->code = 3;
          else if (event.button.x > 358 && event.button.x < 498 && event.button.y > 275 && event.button.y < 297)    // If the 'departurename' text field is selected
            data->code = 4;
          else if (event.button.x > 358 && event.button.x < 498 && event.button.y > 325 && event.button.y < 347)    // If the 'arrivalname' text field is selected
            data->code = 5;
          else if (event.button.x > 10 && event.button.x < 30 && event.button.y > 150 && event.button.y < 170)    // If the 'A star' box is checked
            data->code = 6;
          else if (event.button.x > 10 && event.button.x < 30 && event.button.y > 180 && event.button.y < 200)    // If the 'Dijkstra' box is checked
            data->code = 7;
          else if (event.button.x > 170 && event.button.x < 190 && event.button.y > 150 && event.button.y < 170)      // If the 'BFS' box is checked
            data->code = 8;
          else if (event.button.x > 170 && event.button.x < 190 && event.button.y > 180 && event.button.y < 200)      // If the 'DFS' box is checked
            data->code = 9;
          else if (event.button.x > 620 && event.button.x < 640 && event.button.y > 220 && event.button.y < 240)      // If the 'Great Circle heuristic' box is checked
            data->code = 10;
          else if (event.button.x > 620 && event.button.x < 640 && event.button.y > 260 && event.button.y < 280)      // If the 'Manhattan heuristic' box is checked
            data->code = 11;
          else if (event.button.x > 620 && event.button.x < 640 && event.button.y > 300 && event.button.y < 320)      // If the 'Euclidean heuristic' box is checked
            data->code = 12;
          else if (event.button.x > 620 && event.button.x < 640 && event.button.y > 340 && event.button.y < 360)      // If the 'Octile heuristic' box is checked
            data->code = 13;
          else if (event.button.x > 620 && event.button.x < 640 && event.button.y > 380 && event.button.y < 400)      // If the 'Chebyshev heuristic' box is checked
            data->code = 14;
          else if (event.button.x > 350 && event.button.x < 500 && event.button.y > 525 && event.button.y < 552)    // If the 'submit' button is pressed
            data->code = 15;
          else                      // If the user has clicked somewhere other than the text fields or the boxes
            data->code = 0;         // Update data.code to prevent writing letters next time

          if (data->code > 0) {     // If the user has clicked in a text field or in a case
            status = 0;               // We can quit the function
          }
        }
      break;
    }
  }
}



// Update the cases in the algorithm dataform (the one with the index 'index' is checked, the others are all unchecked)
// Return nothing
void updateCasesAlgo(object_t* imgcase, SDL_Surface* screen, int index) {
  int i;
  for (i = 0; i < 4; i++) {
    if (i == index)
      imgcase[i].surface = SDL_LoadBMP("image/case_checked.bmp");   // Selected case
    else
      imgcase[i].surface = SDL_LoadBMP("image/case.bmp");     // Other cases that are not selected
    SDL_BlitSurface(imgcase[i].surface, NULL, screen, &(imgcase[i].position));
  }
  SDL_Flip(screen);                       // Update the whole SDL window
}



// Update the cases in the heuristic dataform (the one with the index 'index' is checked, the others are all unchecked)
// Return nothing
void updateCasesHeur(object_t* imgcase, SDL_Surface* screen, int index) {
  int i;
  for (i = 4; i < 9; i++) {
    if (i == index)
      imgcase[i].surface = SDL_LoadBMP("image/case_checked.bmp");     // Selected case
    else
      imgcase[i].surface = SDL_LoadBMP("image/case.bmp");         // Other cases that are not selected
    SDL_BlitSurface(imgcase[i].surface, NULL, screen, &(imgcase[i].position));
  }
  SDL_Flip(screen);                       // Update the whole SDL window
}



// Display the text written by the user in the selected text field
// Perform the character deleting if necessary
// Return nothing
void textDisplay(datauser_t data, SDL_Surface* screen) {
  switch (data.code) {
    case 1:
      if (data.string != '\0') {

      }
      else if (data.accent != '\0') {

      }
      else if (data.control == 2) {

      }
      else {
        errorMsg("Should not be here.");
        return;
      }
      break;
    case 2:
    case 3:
    case 4:
    case 5:
    default:
      errorMsg("Should not be here.");
      return;
  }
  SDL_Flip(screen);
}



// Selected text fields become red when selected
// Return nothing
void fieldSelected(int code, object_t* sep, SDL_Surface* screen) {
  int i;
  for (i = 1; i < 21; i++) {          // First all text field separators are reset in black color
    SDL_FillRect((sep[i]).surface, NULL, SDL_MapRGB(((sep[i]).surface)->format, 0, 0, 0));
    SDL_BlitSurface((sep[i]).surface, NULL, screen, &(sep[i].position));
  }
  switch(code) {      // Then the selected text field separators are set in red color
    case 1:             // "filename" text field
      for (i = 1; i < 5; i++) {
        SDL_FillRect((sep[i]).surface, NULL, SDL_MapRGB(((sep[i]).surface)->format, 255, 0, 0));
        SDL_BlitSurface((sep[i]).surface, NULL, screen, &(sep[i].position));
      }
      break;
    case 2:       // "departureindex" text field
      for (i = 5; i < 9; i++) {
        SDL_FillRect((sep[i]).surface, NULL, SDL_MapRGB(((sep[i]).surface)->format, 255, 0, 0));
        SDL_BlitSurface((sep[i]).surface, NULL, screen, &(sep[i].position));
      }
      break;
    case 3:     // "arrivalindex" text field
      for (i = 9; i < 13; i++) {
        SDL_FillRect((sep[i]).surface, NULL, SDL_MapRGB(((sep[i]).surface)->format, 255, 0, 0));
        SDL_BlitSurface((sep[i]).surface, NULL, screen, &(sep[i].position));
      }
      break;
    case 4:     // "departurename" text field
      for (i = 13; i < 17; i++) {
        SDL_FillRect((sep[i]).surface, NULL, SDL_MapRGB(((sep[i]).surface)->format, 255, 0, 0));
        SDL_BlitSurface((sep[i]).surface, NULL, screen, &(sep[i].position));
      }
      break;
    case 5:       // "arrivalname" text field
      for (i = 17; i < 21; i++) {
        SDL_FillRect((sep[i]).surface, NULL, SDL_MapRGB(((sep[i]).surface)->format, 255, 0, 0));
        SDL_BlitSurface((sep[i]).surface, NULL, screen, &(sep[i].position));
      }
      break;
    default:
      errorMsg("Should not be here.");
      return;
  }
  SDL_Flip(screen);       // Update the whole SDL window
}


// Display a graphic dataform to get user informations : pathfinder algorithm, graph name, departure and arrival node indexes and heuristic function
// Return -1 if an error occured, 0 otherwise
int dataForm(char* filename, char* departurename, char* arrivalname, char* departureindex, char* arrivalindex, void (**algo)(graph_t graph, int dep, int arriv, double (*heuristic)(double nx, double ny, double lat, double longi)), double (**heuristic)(double nx, double ny, double lat, double longi)) {
  int i;
  datauser_t data;          // To store user data
  SDL_Surface* screen = NULL;         // The global SDL screen
  SDL_Surface* text[27] = {NULL};       // SDL surfaces for textes
  object_t imgcase[11];               // SDL surfaces for images
  for (i = 0; i < 11; i++) {
    imgcase[i].surface = NULL;
  }
  object_t separator[23];           // SDL surfaces for separators
  for (i = 0; i < 23; i++) {
    separator[i].surface = NULL;
  }
  SDL_Rect position, positionfile, positionindexdep, positionindexarriv, positionnamedep, positionnamearriv;                     // SDL surfaces position in the window
  positionfile.x = 259;
  positionfile.y = 394;
  positionindexdep.x = 179;
  positionindexdep.y = 275;
  positionindexarriv.x = 179;
  positionindexarriv.y = 325;
  positionnamedep.x = 362;
  positionnamedep.y = 275;
  positionnamearriv.x = 362;
  positionnamearriv.y = 325;
  TTF_Font* police1 = NULL;             // Police for the main title
  TTF_Font* police2 = NULL;           // Police for paragraph titles
  TTF_Font* police3 = NULL;             // Police for standard text
  SDL_Color white = {255, 255, 255};        // Definition of white color
  SDL_Color green = {194, 247, 50};         // Definition of green color
  if (SDL_Init(SDL_INIT_VIDEO) == -1) {                         // initialisation of SDL
    fprintf(stderr, "SDL initialisation error : %s\n", SDL_GetError());
    return -1;
  }
  if (TTF_Init() == -1) {                       // initialisation of TTF
    fprintf(stderr, "TTF initialisation error : %s\n", TTF_GetError());
    exit(EXIT_FAILURE);
  }
  screen = SDL_SetVideoMode(WIDTH, HEIGHT, 32, SDL_HWSURFACE);        // SDL window settings
  if (screen == NULL) {
    fprintf(stderr, "SDL screen initialisation error : %s\n", SDL_GetError());
    SDL_Quit();
    return -1;
  }
  police1 = TTF_OpenFont("police/clootie.otf", 50);       // Police for the main title
  police2 = TTF_OpenFont("police/clootie.otf", 35);       // Police for paragraph titles
  police3 = TTF_OpenFont("police/clootie.otf", 20);        // Police for standard text
  SDL_WM_SetCaption("Pathfinder algorithms - Dataform", NULL);        // Set the window title

  SDL_FillRect(screen, NULL, SDL_MapRGB(screen->format, 50, 50, 50));       // Fill the whole window with grey color

  text[0] = TTF_RenderText_Blended(police1, "Pathfinder algorithms", white);      // Main title
  position.x = 10;
  position.y = 0;
  SDL_BlitSurface(text[0], NULL, screen, &position);              // Add the main title to the SDL window
  text[1] = TTF_RenderText_Blended(police3, "A Star", white);
  position.x = 50;
  position.y = 147;
  SDL_BlitSurface(text[1], NULL, screen, &position);
  text[2] = TTF_RenderText_Blended(police3, "Dijkstra", white);
  position.x = 50;
  position.y = 177;
  SDL_BlitSurface(text[2], NULL, screen, &position);
  text[3] = TTF_RenderText_Blended(police2, "Which algorithm ?", white);
  position.x = 10;
  position.y = 90;
  SDL_BlitSurface(text[3], NULL, screen, &position);
  text[4] = TTF_RenderText_Blended(police3, "START node", white);
  position.x = 10;
  position.y = 275;
  SDL_BlitSurface(text[4], NULL, screen, &position);
  text[5] = TTF_RenderText_Blended(police3, "END node", white);
  position.x = 10;
  position.y = 325;
  SDL_BlitSurface(text[5], NULL, screen, &position);
  text[6] = TTF_RenderText_Blended(police3, "Index :", white);
  position.x = 120;
  position.y = 275;
  SDL_BlitSurface(text[6], NULL, screen, &position);
  text[7] = TTF_RenderText_Blended(police3, "Or    node name :", white);
  position.x = 230;
  position.y = 275;
  SDL_BlitSurface(text[7], NULL, screen, &position);
  text[8] = TTF_RenderText_Blended(police3, "Index :", white);
  position.x = 120;
  position.y = 325;
  SDL_BlitSurface(text[8], NULL, screen, &position);
  text[9] = TTF_RenderText_Blended(police3, "Or    node name :", white);
  position.x = 230;
  position.y = 325;
  SDL_BlitSurface(text[9], NULL, screen, &position);
  text[10] = TTF_RenderText_Blended(police2, "Departure and arrival nodes", white);
  position.x = 10;
  position.y = 225;
  SDL_BlitSurface(text[10], NULL, screen, &position);
  text[11] = TTF_RenderText_Blended(police3, "Breadth First Search", white);
  position.x = 210;
  position.y = 147;
  SDL_BlitSurface(text[11], NULL, screen, &position);
  text[12] = TTF_RenderText_Blended(police3, "Depth First Search", white);
  position.x = 210;
  position.y = 177;
  SDL_BlitSurface(text[12], NULL, screen, &position);
  text[13] = TTF_RenderText_Blended(police2, "Graph data", white);
  position.x = 10;
  position.y = 380;
  SDL_BlitSurface(text[13], NULL, screen, &position);
  text[14] = TTF_RenderText_Blended(police3, "Filename :", white);
  position.x = 180;
  position.y = 395;
  SDL_BlitSurface(text[14], NULL, screen, &position);
  text[15] = TTF_RenderText_Blended(police2, "Which heuristic function ?", white);
  position.x = 500;
  position.y = 155;
  SDL_BlitSurface(text[15], NULL, screen, &position);
  text[16] = TTF_RenderText_Blended(police3, "Great circle", white);
  position.x = 660;
  position.y = 217;
  SDL_BlitSurface(text[16], NULL, screen, &position);
  text[17] = TTF_RenderText_Blended(police3, "Manhattan", white);
  position.y = 257;
  SDL_BlitSurface(text[17], NULL, screen, &position);
  text[18] = TTF_RenderText_Blended(police3, "Euclidean", white);
  position.y = 297;
  SDL_BlitSurface(text[18], NULL, screen, &position);
  text[19] = TTF_RenderText_Blended(police3, "Octile", white);
  position.y = 337;
  SDL_BlitSurface(text[19], NULL, screen, &position);
  text[20] = TTF_RenderText_Blended(police3, "Chebyshev", white);
  position.y = 377;
  SDL_BlitSurface(text[20], NULL, screen, &position);
  text[21] = TTF_RenderText_Blended(police3, "(Leave all text fields blank to work on the grid)", white);
  position.x = 245;
  position.y = 430;
  SDL_BlitSurface(text[21], NULL, screen, &position);

  (separator[0]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 500, 1, 32, 0, 0, 0, 0);       // Separator line between 'START node' and 'END node'
  SDL_FillRect((separator[0]).surface, NULL, SDL_MapRGB(((separator[0]).surface)->format, 255, 255, 255));      // Set the color to white
  (separator[0]).position.x = 10;
  (separator[0]).position.y = 310;
  SDL_BlitSurface((separator[0]).surface, NULL, screen, &(separator[0].position));                       // Add the separator to the SDL window
  (separator[1]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 2, 22, 32, 0, 0, 0, 0);
  (separator[2]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 200, 2, 32, 0, 0, 0, 0);
  (separator[3]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 2, 22, 32, 0, 0, 0, 0);
  (separator[4]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 200, 2, 32, 0, 0, 0, 0);
  for (i = 1; i < 5; i++)
    SDL_FillRect((separator[i]).surface, NULL, SDL_MapRGB(((separator[i]).surface)->format, 0, 0, 0));      // Separators that delimit the text field 'filename'
  (separator[1]).position.x = 255;
  (separator[1]).position.y = 394;
  SDL_BlitSurface((separator[1]).surface, NULL, screen, &((separator[1]).position));
  (separator[2]).position.x = 255;
  (separator[2]).position.y = 394;
  SDL_BlitSurface((separator[2]).surface, NULL, screen, &((separator[2]).position));
  (separator[3]).position.x = 455;
  (separator[3]).position.y = 394;
  SDL_BlitSurface(separator[3].surface, NULL, screen, &((separator[3]).position));
  (separator[4]).position.x = 255;
  (separator[4]).position.y = 416;
  SDL_BlitSurface(separator[4].surface, NULL, screen, &((separator[4]).position));
  (separator[5]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 2, 22, 32, 0, 0, 0, 0);
  (separator[6]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 30, 2, 32, 0, 0, 0, 0);
  (separator[7]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 2, 22, 32, 0, 0, 0, 0);
  (separator[8]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 30, 2, 32, 0, 0, 0, 0);
  for (i = 5; i < 9; i++)
    SDL_FillRect((separator[i]).surface, NULL, SDL_MapRGB(((separator[i]).surface)->format, 0, 0, 0));    // Separators that delimit the text field 'departureindex'
  (separator[5]).position.x = 175;
  (separator[5]).position.y = 275;
  SDL_BlitSurface((separator[5]).surface, NULL, screen, &((separator[5]).position));
  (separator[6]).position.x = 175;
  (separator[6]).position.y = 275;
  SDL_BlitSurface((separator[6]).surface, NULL, screen, &((separator[6]).position));
  (separator[7]).position.x = 205;
  (separator[7]).position.y = 275;
  SDL_BlitSurface((separator[7]).surface, NULL, screen, &((separator[7]).position));
  (separator[8]).position.x = 175;
  (separator[8]).position.y = 297;
  SDL_BlitSurface((separator[8]).surface, NULL, screen, &((separator[8]).position));
  (separator[9]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 2, 22, 32, 0, 0, 0, 0);
  (separator[10]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 30, 2, 32, 0, 0, 0, 0);
  (separator[11]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 2, 22, 32, 0, 0, 0, 0);
  (separator[12]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 30, 2, 32, 0, 0, 0, 0);
  for (i = 9; i < 13; i++)
    SDL_FillRect((separator[i]).surface, NULL, SDL_MapRGB(((separator[i]).surface)->format, 0, 0, 0));    // Separators that delimit the text field 'arrivalindex'
  (separator[9]).position.x = 175;
  (separator[9]).position.y = 325;
  SDL_BlitSurface((separator[9]).surface, NULL, screen, &((separator[9]).position));
  (separator[10]).position.x = 175;
  (separator[10]).position.y = 325;
  SDL_BlitSurface((separator[10]).surface, NULL, screen, &((separator[10]).position));
  (separator[11]).position.x = 205;
  (separator[11]).position.y = 325;
  SDL_BlitSurface((separator[11]).surface, NULL, screen, &((separator[11]).position));
  (separator[12]).position.x = 175;
  (separator[12]).position.y = 347;
  SDL_BlitSurface((separator[12]).surface, NULL, screen, &((separator[12]).position));
  separator[13].surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 2, 22, 32, 0, 0, 0, 0);
  separator[14].surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 140, 2, 32, 0, 0, 0, 0);
  separator[15].surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 2, 22, 32, 0, 0, 0, 0);
  separator[16].surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 140, 2, 32, 0, 0, 0, 0);
  for (i = 13; i < 17; i++)
    SDL_FillRect((separator[i]).surface, NULL, SDL_MapRGB(((separator[i]).surface)->format, 0, 0, 0));      // Separators that delimit the text field 'departurename'
  (separator[13]).position.x = 358;
  (separator[13]).position.y = 275;
  SDL_BlitSurface((separator[13]).surface, NULL, screen, &((separator[13]).position));
  (separator[14]).position.x = 358;
  (separator[14]).position.y = 275;
  SDL_BlitSurface((separator[14]).surface, NULL, screen, &((separator[14]).position));
  (separator[15]).position.x = 498;
  (separator[15]).position.y = 275;
  SDL_BlitSurface((separator[15]).surface, NULL, screen, &((separator[15]).position));
  (separator[16]).position.x = 358;
  (separator[16]).position.y = 297;
  SDL_BlitSurface((separator[16]).surface, NULL, screen, &((separator[16]).position));
  (separator[17]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 2, 22, 32, 0, 0, 0, 0);
  (separator[18]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 140, 2, 32, 0, 0, 0, 0);
  (separator[19]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 2, 22, 32, 0, 0, 0, 0);
  (separator[20]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 140, 2, 32, 0, 0, 0, 0);
  for (i = 17; i < 21; i++)
    SDL_FillRect((separator[i]).surface, NULL, SDL_MapRGB(((separator[i]).surface)->format, 0, 0, 0));      // Separators that delimit the text field 'arrivalname'
  (separator[17]).position.x = 358;
  (separator[17]).position.y = 325;
  SDL_BlitSurface((separator[17]).surface, NULL, screen, &((separator[17]).position));
  (separator[18]).position.x = 358;
  (separator[18]).position.y = 325;
  SDL_BlitSurface((separator[18]).surface, NULL, screen, &((separator[18]).position));
  (separator[19]).position.x = 498;
  (separator[19]).position.y = 325;
  SDL_BlitSurface((separator[19]).surface, NULL, screen, &((separator[19]).position));
  (separator[20]).position.x = 358;
  (separator[20]).position.y = 347;
  SDL_BlitSurface((separator[20]).surface, NULL, screen, &((separator[20]).position));

  for (i = 0; i < 9; i++)
    (imgcase[i]).surface = SDL_LoadBMP("image/case.bmp");     // Load 'box' image in SDL surfaces
  imgcase[0].position.x = 10;
  imgcase[0].position.y = 150;
  SDL_BlitSurface(imgcase[0].surface, NULL, screen, &(imgcase[0].position));
  imgcase[1].position.x = 10;
  imgcase[1].position.y = 180;
  SDL_BlitSurface(imgcase[1].surface, NULL, screen, &(imgcase[1].position));
  imgcase[2].position.x = 170;
  imgcase[2].position.y = 150;
  SDL_BlitSurface(imgcase[2].surface, NULL, screen, &(imgcase[2].position));
  imgcase[3].position.x = 170;
  imgcase[3].position.y = 180;
  SDL_BlitSurface(imgcase[3].surface, NULL, screen, &(imgcase[3].position));
  imgcase[4].position.x = 620;
  imgcase[4].position.y = 220;
  SDL_BlitSurface(imgcase[4].surface, NULL, screen, &(imgcase[4].position));
  imgcase[5].position.x = 620;
  imgcase[5].position.y = 260;
  SDL_BlitSurface(imgcase[5].surface, NULL, screen, &(imgcase[5].position));
  imgcase[6].position.x = 620;
  imgcase[6].position.y = 300;
  SDL_BlitSurface(imgcase[6].surface, NULL, screen, &(imgcase[6].position));
  imgcase[7].position.x = 620;
  imgcase[7].position.y = 340;
  SDL_BlitSurface(imgcase[7].surface, NULL, screen, &(imgcase[7].position));
  imgcase[8].position.x = 620;
  imgcase[8].position.y = 380;
  SDL_BlitSurface(imgcase[8].surface, NULL, screen, &(imgcase[8].position));
  imgcase[9].surface = SDL_LoadBMP("image/apply_button.bmp");         // Load 'submit' button in the SDL surface
  imgcase[9].position.x = WIDTH/2 - ((imgcase[9].surface)->w) / 2;
  imgcase[9].position.y = 525;
  SDL_BlitSurface(imgcase[9].surface, NULL, screen, &(imgcase[9].position));
  imgcase[10].surface = SDL_LoadBMP("image/algorithm_grid.bmp");      // Load 'algorithm_grid.bmp' image in SDL surface
  imgcase[10].position.x = WIDTH - (imgcase[10].surface)->w - 1;
  imgcase[10].position.y = 1;
  SDL_BlitSurface(imgcase[10].surface, NULL, screen, &(imgcase[10].position));

  SDL_Flip(screen);                       // Update the whole SDL window
  data.code = 0;              // Initialize data.code
  data.control = 0;           // Initialize data.control
  data.string = '\0';         // Initialize data.string
  data.accent = calloc(16, sizeof(char));
  if (data.accent == NULL) {
    errorMsg("Error when allocating memory to data.accent");
    return -1;
  }
  (data.accent)[0] = '\0';      // Initialize data.accent
  while (data.code != -1 && data.code != 15) {      // As long as the user has not left the window (code = -1) or clicked on 'submit' button (code = 15)
    processEvent(&data);            // Wait for an user event

    if (data.string != '\0') {            // If a character has been registered
      switch(data.code) {                 // To determine which text field
        case 1:                               // 'filename' text field
          sprintf(filename, "%s%c", filename, data.string);       // Concatenate the character at the end of the word 'filename'
          text[22] = TTF_RenderText_Blended(police3, filename, green);
          SDL_BlitSurface(text[22], NULL, screen, &positionfile);
          break;
        case 2:                               // 'departureindex' text field
          sprintf(departureindex, "%s%c", departureindex, data.string);       // Concatenate the character at the end of the word 'departureindex'
          text[23] = TTF_RenderText_Blended(police3, departureindex, green);
          SDL_BlitSurface(text[23], NULL, screen, &positionindexdep);
          break;
        case 3:                                   // 'arrivalindex' text field
          sprintf(arrivalindex, "%s%c", arrivalindex, data.string);       // Concatenate the character at the end of the word 'arrivalindex'
          text[24] = TTF_RenderText_Blended(police3, arrivalindex, green);
          SDL_BlitSurface(text[24], NULL, screen, &positionindexarriv);
          break;
        case 4:                                 // 'departurename' text field
          sprintf(departurename, "%s%c", departurename, data.string);           // Concatenate the character at the end of the word 'departurename'
          text[25] = TTF_RenderText_Blended(police3, departurename, green);
          SDL_BlitSurface(text[25], NULL, screen, &positionnamedep);
          break;
        case 5:                                 // 'arrivalname' text field
          sprintf(arrivalname, "%s%c", arrivalname, data.string);           // Concatenate the character at the end of the word 'arrivalname'
          text[26] = TTF_RenderText_Blended(police3, arrivalname, green);
          SDL_BlitSurface(text[26], NULL, screen, &positionnamearriv);
          break;
        default:
          errorMsg("Should not be here");         // Because the user enters a character but no text field is selected
          free(data.accent);
          return -1;
      }
    SDL_Flip(screen);         // Update the whole SDL window
    data.string = '\0';         // Reset data.string
    }

    else if ((data.accent)[0] != '\0') {          // A special character has been chosen
      switch(data.code) {                 // To determine which text field
        case 1:                               // 'filename' text field
          sprintf(filename, "%s%s", filename, data.accent);       // Concatenate the character at the end of the word 'filename'
          text[22] = TTF_RenderText_Blended(police3, filename, green);
          SDL_BlitSurface(text[22], NULL, screen, &positionfile);
          break;
        case 2:                               // 'departureindex' text field
          sprintf(departureindex, "%s%s", departureindex, data.accent);       // Concatenate the character at the end of the word 'departureindex'
          text[23] = TTF_RenderText_Blended(police3, departureindex, green);
          SDL_BlitSurface(text[23], NULL, screen, &positionindexdep);
          break;
        case 3:                                   // 'arrivalindex' text field
          sprintf(arrivalindex, "%s%s", arrivalindex, data.accent);       // Concatenate the character at the end of the word 'arrivalindex'
          text[24] = TTF_RenderText_Blended(police3, arrivalindex, green);
          SDL_BlitSurface(text[24], NULL, screen, &positionindexarriv);
          break;
        case 4:                                 // 'departurename' text field
          sprintf(departurename, "%s%s", departurename, data.accent);           // Concatenate the character at the end of the word 'departurename'
          text[25] = TTF_RenderText_Blended(police3, departurename, green);
          SDL_BlitSurface(text[25], NULL, screen, &positionnamedep);
          break;
        case 5:                                 // 'arrivalname' text field
          sprintf(arrivalname, "%s%s", arrivalname, data.accent);           // Concatenate the character at the end of the word 'arrivalname'
          text[26] = TTF_RenderText_Blended(police3, arrivalname, green);
          SDL_BlitSurface(text[26], NULL, screen, &positionnamearriv);
          break;
        default:
          errorMsg("Should not be here");         // Because the user enters a character but no text field has been selected
          free(data.accent);
          return -1;
      }
      SDL_Flip(screen);         // Update the whole SDL window
      data.accent[0] = '\0';      // Reset data.accent
    }
    if (data.code > 0 && data.code < 6) {              // If the user is using a text field
      fieldSelected(data.code, separator, screen);     // Text fields become red when selected
      if (data.control == 2) {        // If "DELETE" key has been pressed
        switch(data.code) {
          case 1:                               // 'filename' text field
            if (filename[0] != '\0') {        // If the text field is not already empty
              filename[strlen(filename)-1] = '\0';            // The last character is deleted
              (separator[22]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 198, 20, 32, 0, 0, 0, 0);
              SDL_FillRect((separator[22]).surface, NULL, SDL_MapRGB(((separator[22]).surface)->format, 50, 50, 50));
              (separator[22]).position.x = (separator[1]).position.x + 2;
              (separator[22]).position.y = (separator[1]).position.y + 2;
              SDL_BlitSurface((separator[22]).surface, NULL, screen, &((separator[22]).position));
              text[22] = TTF_RenderText_Blended(police3, filename, green);
              SDL_BlitSurface(text[22], NULL, screen, &positionfile);
            }
            break;
          case 2:                               // 'departureindex' text field
            if (departureindex[0] != '\0') {        // If the text field is not already empty
              departureindex[strlen(departureindex)-1] = '\0';            // The last character is deleted
              (separator[22]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 28, 20, 32, 0, 0, 0, 0);
              SDL_FillRect((separator[22]).surface, NULL, SDL_MapRGB(((separator[22]).surface)->format, 50, 50, 50));
              (separator[22]).position.x = (separator[5]).position.x + 2;
              (separator[22]).position.y = (separator[5]).position.y + 2;
              SDL_BlitSurface((separator[22]).surface, NULL, screen, &((separator[22]).position));
              text[23] = TTF_RenderText_Blended(police3, departureindex, green);
              SDL_BlitSurface(text[23], NULL, screen, &positionindexdep);
            }
            break;
          case 3:                                   // 'arrivalindex' text field
            if (arrivalindex[0] != '\0') {        // If the text field is not already empty
              arrivalindex[strlen(arrivalindex)-1] = '\0';            // The last character is deleted
              (separator[22]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 28, 20, 32, 0, 0, 0, 0);
              SDL_FillRect((separator[22]).surface, NULL, SDL_MapRGB(((separator[22]).surface)->format, 50, 50, 50));
              (separator[22]).position.x = (separator[9]).position.x + 2;
              (separator[22]).position.y = (separator[9]).position.y + 2;
              SDL_BlitSurface((separator[22]).surface, NULL, screen, &((separator[22]).position));
              text[24] = TTF_RenderText_Blended(police3, arrivalindex, green);
              SDL_BlitSurface(text[24], NULL, screen, &positionindexarriv);
            }
            break;
          case 4:                                 // 'departurename' text field
            if (departurename[0] != '\0') {        // If the text field is not already empty
              departurename[strlen(departurename)-1] = '\0';            // The last character is deleted
              (separator[22]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 138, 20, 32, 0, 0, 0, 0);
              SDL_FillRect((separator[22]).surface, NULL, SDL_MapRGB(((separator[22]).surface)->format, 50, 50, 50));
              (separator[22]).position.x = (separator[13]).position.x + 2;
              (separator[22]).position.y = (separator[13]).position.y + 2;
              SDL_BlitSurface((separator[22]).surface, NULL, screen, &((separator[22]).position));
              text[25] = TTF_RenderText_Blended(police3, departurename, green);
              SDL_BlitSurface(text[25], NULL, screen, &positionnamedep);
            }
            break;
          case 5:                                 // 'arrivalname' text field
            if (arrivalname[0] != '\0') {        // If the text field is not already empty
              arrivalname[strlen(arrivalname)-1] = '\0';            // The last character is deleted
              (separator[22]).surface = SDL_CreateRGBSurface(SDL_HWSURFACE, 138, 20, 32, 0, 0, 0, 0);
              SDL_FillRect((separator[22]).surface, NULL, SDL_MapRGB(((separator[22]).surface)->format, 50, 50, 50));
              (separator[22]).position.x = (separator[17]).position.x + 2;
              (separator[22]).position.y = (separator[17]).position.y + 2;
              SDL_BlitSurface((separator[22]).surface, NULL, screen, &((separator[22]).position));
              text[26] = TTF_RenderText_Blended(police3, arrivalname, green);
              SDL_BlitSurface(text[26], NULL, screen, &positionnamearriv);
            }
            break;
        }
        SDL_Flip(screen);       // Update the whole SDL screen
        data.control = 0;       // Data.control is reset to 0
      }
    }
    else if (data.code > 5 && data.code < 10) {      // Else if an algorithm box has been checked
      switch(data.code) {       // To determine which box has been checked
        case 6:           // Astar
          *algo = &pathfinder1;       // Pointer to A Star function
          break;
        case 7:           // Dijkstra
          *algo = &pathfinder1;       // Pointer to Dijkstra function
          break;
        case 8:           // BFS
          *algo = &pathfinder2;             // Pointer to BFS function
          break;
        case 9:           // DFS
          *algo = &pathfinder3;             // Pointer to DFS function
          break;
        default:
          errorMsg("Should never be here");     // Because the user has checked a box but none of boxes has been checked
          free(data.accent);
          return -1;
      }
      updateCasesAlgo(imgcase, screen, (data.code)-6);
    }
    else if (data.code > 9 && data.code < 15) {     // Else if a heuristic function box has been checked
      switch(data.code) {
        case 10:
          *heuristic = &greatCircle;      // Function pointer to heuristic function "greatCircle"
          break;
        case 11:
          *heuristic = &manhattan;      // Function pointer to heuristic function "manhattan"
          break;
        case 12:
          *heuristic = &euclidean;      // Function pointer to heuristic function "euclidean"
          break;
        case 13:
          *heuristic = &octile;       // Function pointer to heuristic function "octile"
          break;
        case 14:
          *heuristic = &chebyshev;      // Function pointer to heuristic function "chebyshev"
          break;
        default:
          errorMsg("Should never be here");     // Because the user has checked a box but none of boxes has been checked
          free(data.accent);
          return -1;
      }
      updateCasesHeur(imgcase, screen, (data.code)-6);
    }
  }

  for (i = 0; i < 27; i++)      // Free memory allocated to text SDL surfaces
    SDL_FreeSurface(text[i]);
  for (i = 0; i < 11; i++)        // Free memory allocated to image SDL surfaces
    SDL_FreeSurface(imgcase[i].surface);
  for (i = 0; i < 23; i++)          // Free memory allocated to separator SDL surfaces
    SDL_FreeSurface(separator[i].surface);
  SDL_FreeSurface(screen);          // Free memory allocated to the main SDL screen
  TTF_CloseFont(police1);         // Close TTF police
  TTF_CloseFont(police2);         // Close TTF police
  TTF_CloseFont(police3);         // Close TTF police
  TTF_Quit();                 // Close TTF
  SDL_Quit();               // Close SDL
  free(data.accent);
  if (data.code == -1)    // User asks to leave the window
    return -1;
  return 0;       // User has clicked on "submit" button
}
